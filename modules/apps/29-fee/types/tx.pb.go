// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/applications/fee/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/ibc-go/v3/modules/core/04-channel/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgRegisterCounterpartyAddress is the request type for registering the counterparty address
type MsgRegisterCounterpartyAddress struct {
	Address             string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	CounterpartyAddress string `protobuf:"bytes,2,opt,name=counterparty_address,json=counterpartyAddress,proto3" json:"counterparty_address,omitempty" yaml:"counterparty_address"`
}

func (m *MsgRegisterCounterpartyAddress) Reset()         { *m = MsgRegisterCounterpartyAddress{} }
func (m *MsgRegisterCounterpartyAddress) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterCounterpartyAddress) ProtoMessage()    {}
func (*MsgRegisterCounterpartyAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{0}
}
func (m *MsgRegisterCounterpartyAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterCounterpartyAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterCounterpartyAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterCounterpartyAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterCounterpartyAddress.Merge(m, src)
}
func (m *MsgRegisterCounterpartyAddress) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterCounterpartyAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterCounterpartyAddress.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterCounterpartyAddress proto.InternalMessageInfo

// MsgRegisterCounterpartyAddressResponse defines the Msg/RegisterCounterypartyAddress response type
type MsgRegisterCounterpartyAddressResponse struct {
}

func (m *MsgRegisterCounterpartyAddressResponse) Reset() {
	*m = MsgRegisterCounterpartyAddressResponse{}
}
func (m *MsgRegisterCounterpartyAddressResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterCounterpartyAddressResponse) ProtoMessage()    {}
func (*MsgRegisterCounterpartyAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{1}
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterCounterpartyAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterCounterpartyAddressResponse.Merge(m, src)
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterCounterpartyAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterCounterpartyAddressResponse proto.InternalMessageInfo

// MsgPayPacketFee defines the request type PayPacketFee RPC
// This Msg can be used to pay for a packet at the next sequence send & should be combined with the Msg that will be
// paid for
type MsgPayPacketFee struct {
	Fee Fee `protobuf:"bytes,1,opt,name=fee,proto3" json:"fee"`
	// source channel port identifier
	SourcePortId string `protobuf:"bytes,2,opt,name=source_port_id,json=sourcePortId,proto3" json:"source_port_id,omitempty" yaml:"source_port_id"`
	// source channel unique identifier
	SourceChannelId string `protobuf:"bytes,3,opt,name=source_channel_id,json=sourceChannelId,proto3" json:"source_channel_id,omitempty" yaml:"source_channel_id"`
	// account address to refund fee if necessary
	Signer   string   `protobuf:"bytes,4,opt,name=signer,proto3" json:"signer,omitempty"`
	Relayers []string `protobuf:"bytes,5,rep,name=relayers,proto3" json:"relayers,omitempty"`
}

func (m *MsgPayPacketFee) Reset()         { *m = MsgPayPacketFee{} }
func (m *MsgPayPacketFee) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFee) ProtoMessage()    {}
func (*MsgPayPacketFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{2}
}
func (m *MsgPayPacketFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFee.Merge(m, src)
}
func (m *MsgPayPacketFee) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFee) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFee.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFee proto.InternalMessageInfo

// MsgPayPacketFeeResponse defines the response type for Msg/PayPacketFee
type MsgPayPacketFeeResponse struct {
}

func (m *MsgPayPacketFeeResponse) Reset()         { *m = MsgPayPacketFeeResponse{} }
func (m *MsgPayPacketFeeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFeeResponse) ProtoMessage()    {}
func (*MsgPayPacketFeeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{3}
}
func (m *MsgPayPacketFeeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFeeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFeeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFeeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFeeResponse.Merge(m, src)
}
func (m *MsgPayPacketFeeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFeeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFeeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFeeResponse proto.InternalMessageInfo

// MsgPayPacketFeeAsync defines the request type PayPacketFeeAsync RPC
// This Msg can be used to pay for a packet at a specified sequence (instead of the next sequence send)
type MsgPayPacketFeeAsync struct {
	// identified packet to pay fee for
	// identified fee must contain the refund address which is also signer of this message
	IdentifiedPacketFee IdentifiedPacketFee `protobuf:"bytes,1,opt,name=identified_packet_fee,json=identifiedPacketFee,proto3" json:"identified_packet_fee" yaml:"identified_packet_fee"`
}

func (m *MsgPayPacketFeeAsync) Reset()         { *m = MsgPayPacketFeeAsync{} }
func (m *MsgPayPacketFeeAsync) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFeeAsync) ProtoMessage()    {}
func (*MsgPayPacketFeeAsync) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{4}
}
func (m *MsgPayPacketFeeAsync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFeeAsync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFeeAsync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFeeAsync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFeeAsync.Merge(m, src)
}
func (m *MsgPayPacketFeeAsync) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFeeAsync) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFeeAsync.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFeeAsync proto.InternalMessageInfo

// MsgPayPacketFeeAsyncResponse defines the response type for Msg/PayPacketFeeAsync
type MsgPayPacketFeeAsyncResponse struct {
}

func (m *MsgPayPacketFeeAsyncResponse) Reset()         { *m = MsgPayPacketFeeAsyncResponse{} }
func (m *MsgPayPacketFeeAsyncResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFeeAsyncResponse) ProtoMessage()    {}
func (*MsgPayPacketFeeAsyncResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{5}
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFeeAsyncResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFeeAsyncResponse.Merge(m, src)
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFeeAsyncResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFeeAsyncResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgRegisterCounterpartyAddress)(nil), "ibc.applications.fee.v1.MsgRegisterCounterpartyAddress")
	proto.RegisterType((*MsgRegisterCounterpartyAddressResponse)(nil), "ibc.applications.fee.v1.MsgRegisterCounterpartyAddressResponse")
	proto.RegisterType((*MsgPayPacketFee)(nil), "ibc.applications.fee.v1.MsgPayPacketFee")
	proto.RegisterType((*MsgPayPacketFeeResponse)(nil), "ibc.applications.fee.v1.MsgPayPacketFeeResponse")
	proto.RegisterType((*MsgPayPacketFeeAsync)(nil), "ibc.applications.fee.v1.MsgPayPacketFeeAsync")
	proto.RegisterType((*MsgPayPacketFeeAsyncResponse)(nil), "ibc.applications.fee.v1.MsgPayPacketFeeAsyncResponse")
}

func init() { proto.RegisterFile("ibc/applications/fee/v1/tx.proto", fileDescriptor_05c93128649f1b96) }

var fileDescriptor_05c93128649f1b96 = []byte{
	// 587 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0x4f, 0x4f, 0xdb, 0x4c,
	0x10, 0xc6, 0x6d, 0xc2, 0xcb, 0x0b, 0x5b, 0x54, 0x84, 0x81, 0x12, 0x4c, 0x64, 0x53, 0xab, 0xaa,
	0x72, 0x68, 0xec, 0x12, 0x8a, 0xaa, 0x72, 0x41, 0x04, 0x09, 0x35, 0x87, 0xa8, 0x91, 0x8f, 0xbd,
	0x44, 0xce, 0x7a, 0x62, 0xb6, 0x4d, 0xbc, 0xd6, 0xee, 0x26, 0xaa, 0xbf, 0x00, 0xea, 0x91, 0x5b,
	0x7b, 0xe4, 0xda, 0x6f, 0xc2, 0x91, 0x63, 0x4f, 0x51, 0x95, 0x5c, 0x7a, 0xce, 0x27, 0xa8, 0x6c,
	0x27, 0xc1, 0x21, 0x7f, 0x44, 0x7b, 0xdb, 0xdd, 0xf9, 0xcd, 0xb3, 0x33, 0xcf, 0xae, 0x06, 0x1d,
	0x90, 0x3a, 0xb6, 0x9c, 0x20, 0x68, 0x12, 0xec, 0x08, 0x42, 0x7d, 0x6e, 0x35, 0x00, 0xac, 0xce,
	0xa1, 0x25, 0xbe, 0x98, 0x01, 0xa3, 0x82, 0x2a, 0xbb, 0xa4, 0x8e, 0xcd, 0x34, 0x61, 0x36, 0x00,
	0xcc, 0xce, 0xa1, 0xba, 0xed, 0x51, 0x8f, 0xc6, 0x8c, 0x15, 0xad, 0x12, 0x5c, 0x7d, 0x3e, 0x4f,
	0x30, 0xca, 0x4a, 0x21, 0x98, 0x32, 0xb0, 0xf0, 0xa5, 0xe3, 0xfb, 0xd0, 0x8c, 0xc2, 0xc3, 0x65,
	0x82, 0x18, 0xdf, 0x65, 0xa4, 0x55, 0xb8, 0x67, 0x83, 0x47, 0xb8, 0x00, 0x76, 0x4e, 0xdb, 0xbe,
	0x00, 0x16, 0x38, 0x4c, 0x84, 0x67, 0xae, 0xcb, 0x80, 0x73, 0x25, 0x8b, 0xfe, 0x77, 0x92, 0x65,
	0x56, 0x3e, 0x90, 0xf3, 0x6b, 0xf6, 0x68, 0xab, 0xd8, 0x68, 0x1b, 0xa7, 0x12, 0x6a, 0x23, 0x6c,
	0x29, 0xc2, 0x4a, 0xfa, 0xa0, 0xab, 0xef, 0x87, 0x4e, 0xab, 0x79, 0x62, 0xcc, 0xa2, 0x0c, 0x7b,
	0x0b, 0x4f, 0xdf, 0x76, 0xb2, 0xfa, 0xf5, 0x46, 0x97, 0x7e, 0xdf, 0xe8, 0x92, 0x91, 0x47, 0x2f,
	0x17, 0x57, 0x66, 0x03, 0x0f, 0xa8, 0xcf, 0xc1, 0xb8, 0x5e, 0x42, 0x1b, 0x15, 0xee, 0x55, 0x9d,
	0xb0, 0xea, 0xe0, 0xcf, 0x20, 0x2e, 0x00, 0x94, 0x37, 0x28, 0xd3, 0x00, 0x88, 0x2b, 0x7e, 0x52,
	0xcc, 0x99, 0x73, 0xbc, 0x35, 0x2f, 0x00, 0x4a, 0xcb, 0xb7, 0x5d, 0x5d, 0xb2, 0x23, 0x5c, 0x39,
	0x45, 0x4f, 0x39, 0x6d, 0x33, 0x0c, 0xb5, 0x80, 0x32, 0x51, 0x23, 0xee, 0xb0, 0x97, 0xbd, 0x41,
	0x57, 0xdf, 0x49, 0x7a, 0x99, 0x8c, 0x1b, 0xf6, 0x7a, 0x72, 0x50, 0xa5, 0x4c, 0x94, 0x5d, 0xe5,
	0x3d, 0xda, 0x1c, 0x02, 0x43, 0x9f, 0x23, 0x8d, 0x4c, 0xac, 0x91, 0x1b, 0x74, 0xf5, 0xec, 0x84,
	0xc6, 0x3d, 0x62, 0xd8, 0x1b, 0xc9, 0xd9, 0x79, 0x72, 0x54, 0x76, 0x95, 0x67, 0x68, 0x85, 0x13,
	0xcf, 0x07, 0x96, 0x5d, 0x8e, 0x5d, 0x1f, 0xee, 0x14, 0x15, 0xad, 0x32, 0x68, 0x3a, 0x21, 0x30,
	0x9e, 0xfd, 0xef, 0x20, 0x93, 0x5f, 0xb3, 0xc7, 0xfb, 0x94, 0x79, 0x7b, 0x68, 0xf7, 0x81, 0x23,
	0x63, 0xb7, 0x7e, 0xc8, 0x68, 0xfb, 0x41, 0xec, 0x8c, 0x87, 0x3e, 0x56, 0xae, 0x64, 0xb4, 0x43,
	0x5c, 0xf0, 0x05, 0x69, 0x10, 0x70, 0x6b, 0x41, 0x1c, 0xad, 0xdd, 0xbb, 0xf8, 0x6a, 0xae, 0x8b,
	0xe5, 0x71, 0xd6, 0x58, 0xb2, 0xf4, 0x22, 0x72, 0x75, 0xd0, 0xd5, 0x73, 0x49, 0xcb, 0x33, 0x85,
	0x0d, 0x7b, 0x8b, 0x4c, 0xa7, 0xa6, 0xda, 0xd0, 0x50, 0x6e, 0x56, 0xa9, 0xa3, 0x5e, 0x8a, 0x57,
	0x19, 0x94, 0xa9, 0x70, 0x4f, 0xf9, 0x26, 0xa3, 0xfd, 0x45, 0x7f, 0xf8, 0xed, 0xdc, 0xd2, 0x17,
	0x7f, 0x31, 0xf5, 0xf4, 0x1f, 0x13, 0x47, 0x15, 0x2a, 0x9f, 0xd0, 0xfa, 0xc4, 0xbf, 0xcc, 0x2f,
	0x12, 0x4c, 0x93, 0xea, 0xeb, 0xc7, 0x92, 0xe3, 0xbb, 0x42, 0xb4, 0x39, 0xfd, 0xaa, 0x85, 0xc7,
	0xca, 0xc4, 0xb8, 0x7a, 0xfc, 0x57, 0xf8, 0xe8, 0xea, 0xd2, 0x87, 0xdb, 0x9e, 0x26, 0xdf, 0xf5,
	0x34, 0xf9, 0x57, 0x4f, 0x93, 0xaf, 0xfb, 0x9a, 0x74, 0xd7, 0xd7, 0xa4, 0x9f, 0x7d, 0x4d, 0xfa,
	0x78, 0xec, 0x11, 0x71, 0xd9, 0xae, 0x9b, 0x98, 0xb6, 0x2c, 0x4c, 0x79, 0x8b, 0x72, 0x8b, 0xd4,
	0x71, 0xc1, 0xa3, 0x56, 0xe7, 0xc8, 0x6a, 0x51, 0xb7, 0xdd, 0x04, 0x1e, 0xcd, 0x31, 0x6e, 0x15,
	0xdf, 0x15, 0xa2, 0x11, 0x26, 0xc2, 0x00, 0x78, 0x7d, 0x25, 0x9e, 0x4f, 0x47, 0x7f, 0x02, 0x00,
	0x00, 0xff, 0xff, 0x35, 0x7a, 0x51, 0x8c, 0x38, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// RegisterCounterpartyAddress defines a rpc handler method for MsgRegisterCounterpartyAddress
	// RegisterCounterpartyAddress is called by the relayer on each channelEnd and allows them to specify their
	// counterparty address before relaying. This ensures they will be properly compensated for forward relaying since
	// destination chain must send back relayer's source address (counterparty address) in acknowledgement. This function
	// may be called more than once by a relayer, in which case, latest counterparty address is always used.
	RegisterCounterpartyAddress(ctx context.Context, in *MsgRegisterCounterpartyAddress, opts ...grpc.CallOption) (*MsgRegisterCounterpartyAddressResponse, error)
	// PayPacketFee defines a rpc handler method for MsgPayPacketFee
	// PayPacketFee is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of the packet at the next sequence
	PayPacketFee(ctx context.Context, in *MsgPayPacketFee, opts ...grpc.CallOption) (*MsgPayPacketFeeResponse, error)
	// PayPacketFeeAsync defines a rpc handler method for MsgPayPacketFeeAsync
	// PayPacketFeeAsync is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of a known packet
	PayPacketFeeAsync(ctx context.Context, in *MsgPayPacketFeeAsync, opts ...grpc.CallOption) (*MsgPayPacketFeeAsyncResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) RegisterCounterpartyAddress(ctx context.Context, in *MsgRegisterCounterpartyAddress, opts ...grpc.CallOption) (*MsgRegisterCounterpartyAddressResponse, error) {
	out := new(MsgRegisterCounterpartyAddressResponse)
	err := c.cc.Invoke(ctx, "/ibc.applications.fee.v1.Msg/RegisterCounterpartyAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PayPacketFee(ctx context.Context, in *MsgPayPacketFee, opts ...grpc.CallOption) (*MsgPayPacketFeeResponse, error) {
	out := new(MsgPayPacketFeeResponse)
	err := c.cc.Invoke(ctx, "/ibc.applications.fee.v1.Msg/PayPacketFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PayPacketFeeAsync(ctx context.Context, in *MsgPayPacketFeeAsync, opts ...grpc.CallOption) (*MsgPayPacketFeeAsyncResponse, error) {
	out := new(MsgPayPacketFeeAsyncResponse)
	err := c.cc.Invoke(ctx, "/ibc.applications.fee.v1.Msg/PayPacketFeeAsync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// RegisterCounterpartyAddress defines a rpc handler method for MsgRegisterCounterpartyAddress
	// RegisterCounterpartyAddress is called by the relayer on each channelEnd and allows them to specify their
	// counterparty address before relaying. This ensures they will be properly compensated for forward relaying since
	// destination chain must send back relayer's source address (counterparty address) in acknowledgement. This function
	// may be called more than once by a relayer, in which case, latest counterparty address is always used.
	RegisterCounterpartyAddress(context.Context, *MsgRegisterCounterpartyAddress) (*MsgRegisterCounterpartyAddressResponse, error)
	// PayPacketFee defines a rpc handler method for MsgPayPacketFee
	// PayPacketFee is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of the packet at the next sequence
	PayPacketFee(context.Context, *MsgPayPacketFee) (*MsgPayPacketFeeResponse, error)
	// PayPacketFeeAsync defines a rpc handler method for MsgPayPacketFeeAsync
	// PayPacketFeeAsync is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of a known packet
	PayPacketFeeAsync(context.Context, *MsgPayPacketFeeAsync) (*MsgPayPacketFeeAsyncResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RegisterCounterpartyAddress(ctx context.Context, req *MsgRegisterCounterpartyAddress) (*MsgRegisterCounterpartyAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterCounterpartyAddress not implemented")
}
func (*UnimplementedMsgServer) PayPacketFee(ctx context.Context, req *MsgPayPacketFee) (*MsgPayPacketFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PayPacketFee not implemented")
}
func (*UnimplementedMsgServer) PayPacketFeeAsync(ctx context.Context, req *MsgPayPacketFeeAsync) (*MsgPayPacketFeeAsyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PayPacketFeeAsync not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_RegisterCounterpartyAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterCounterpartyAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterCounterpartyAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.applications.fee.v1.Msg/RegisterCounterpartyAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterCounterpartyAddress(ctx, req.(*MsgRegisterCounterpartyAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PayPacketFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPayPacketFee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PayPacketFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.applications.fee.v1.Msg/PayPacketFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PayPacketFee(ctx, req.(*MsgPayPacketFee))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PayPacketFeeAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPayPacketFeeAsync)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PayPacketFeeAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.applications.fee.v1.Msg/PayPacketFeeAsync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PayPacketFeeAsync(ctx, req.(*MsgPayPacketFeeAsync))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ibc.applications.fee.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterCounterpartyAddress",
			Handler:    _Msg_RegisterCounterpartyAddress_Handler,
		},
		{
			MethodName: "PayPacketFee",
			Handler:    _Msg_PayPacketFee_Handler,
		},
		{
			MethodName: "PayPacketFeeAsync",
			Handler:    _Msg_PayPacketFeeAsync_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ibc/applications/fee/v1/tx.proto",
}

func (m *MsgRegisterCounterpartyAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterCounterpartyAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterCounterpartyAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyAddress) > 0 {
		i -= len(m.CounterpartyAddress)
		copy(dAtA[i:], m.CounterpartyAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterCounterpartyAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterCounterpartyAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterCounterpartyAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayers) > 0 {
		for iNdEx := len(m.Relayers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Relayers[iNdEx])
			copy(dAtA[i:], m.Relayers[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Relayers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SourceChannelId) > 0 {
		i -= len(m.SourceChannelId)
		copy(dAtA[i:], m.SourceChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceChannelId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourcePortId) > 0 {
		i -= len(m.SourcePortId)
		copy(dAtA[i:], m.SourcePortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourcePortId)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFeeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFeeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFeeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFeeAsync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFeeAsync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFeeAsync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.IdentifiedPacketFee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFeeAsyncResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFeeAsyncResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFeeAsyncResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgRegisterCounterpartyAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRegisterCounterpartyAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPayPacketFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Fee.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.SourcePortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Relayers) > 0 {
		for _, s := range m.Relayers {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgPayPacketFeeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPayPacketFeeAsync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.IdentifiedPacketFee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgPayPacketFeeAsyncResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgRegisterCounterpartyAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterCounterpartyAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourcePortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayers = append(m.Relayers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFeeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFeeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFeeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFeeAsync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentifiedPacketFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IdentifiedPacketFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFeeAsyncResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsyncResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsyncResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
